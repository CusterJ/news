package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"News/domain"
	"News/graph/model"
	"context"
	"crypto/rand"
	"fmt"
	"math/big"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) {
	random, _ := rand.Int(rand.Reader, big.NewInt(100))
	todo := &model.Todo{
		Text:   input.Text,
		ID:     fmt.Sprintf("T%d", random),
		User:   &model.User{ID: input.UserID, Name: "user " + input.UserID},
		UserID: input.UserID,
	}
	r.todos = append(r.todos, todo)
	return todo, nil
}

// EditArticle is the resolver for the editArticle field.
func (r *mutationResolver) EditArticle(ctx context.Context, input model.ArticleInput) (*model.Article, error) {
	art := &model.Article{
		Id:          input.ID,
		URL:         input.URL,
		Title:       input.Title,
		Description: input.Description,
		Date:        int64(input.Date),
	}

	if err := r.usecases.EditArticle(domain.Article{
		Id:          input.ID,
		URL:         input.URL,
		Title:       domain.Title{Short: input.Title},
		Description: domain.Description{Long: input.Description},
		Dates:       domain.Dates{Posted: int64(input.Date)},
	}); err != nil {
		return nil, err
	}

	return art, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	return r.todos, nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, take *int, skip *int) ([]*model.Article, error) {
	arts, err := r.usecases.GetArticlesList(ctx, *take, *skip)
	if err != nil {
		return nil, err
	}
	print(len(arts))

	articles := []*model.Article{}

	for _, v := range arts {
		articles = append(articles, &model.Article{
			Id:          v.Id,
			URL:         v.URL,
			Title:       v.Title.Short,
			Description: v.Description.Long,
			Date:        v.Dates.Posted,
		})
	}

	return articles, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id string) (*model.Article, error) {
	art, err := r.usecases.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.Article{
		Id:          art.Id,
		URL:         art.URL,
		Title:       art.Title.Short,
		Description: art.Description.Long,
		Date:        art.Dates.Posted,
	}, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, q string) ([]*model.Article, error) {
	arts, err := r.usecases.Search(ctx, q)
	if err != nil {
		return nil, err
	}

	print(len(arts))

	articles := []*model.Article{}

	for _, v := range arts {
		articles = append(articles, &model.Article{
			Id:          v.Id,
			URL:         v.URL,
			Title:       v.Title.Short,
			Description: v.Description.Long,
			Date:        v.Dates.Posted,
		})
	}

	return articles, nil
}

// User is the resolver for the user field.
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	return &model.User{ID: obj.UserID, Name: "user " + obj.UserID}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Todo returns TodoResolver implementation.
func (r *Resolver) Todo() TodoResolver { return &todoResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
